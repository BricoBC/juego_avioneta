<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Sigmar&display=swap" rel="stylesheet">

  <title>Estefanny Jaquelin Sobrevilla Acosta</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #myCanvas {
      position: fixed;
      /*establece la posiciÃ³n del canvas como fija*/
      top: 0;
      /* coloca el canvas en la parte superior de la pÃ¡gina*/
      left: 0;
      /* coloca el canvas en la esquina superior izquierda de la pÃ¡gina*/
      z-index: -1;
      /* establece el Ã­ndice z en -1, lo que lo coloca detrÃ¡s de otros elementos*/
      width: 100%;
      /* establece el ancho del canvas como el ancho completo de la ventana del navegador*/
      height: 100%;
      /* establece la altura del canvas como la altura completa de la ventana del navegador*/
    }

    #interfaz {
      position: fixed;
      /* establece la posiciÃ³n del div como fija*/
      top: 0;
      /* coloca el div en la parte superior de la pÃ¡gina*/
      left: 0;
      /* coloca el div en la esquina superior izquierda de la pÃ¡gina*/
      z-index: 1;
      /* establece el Ã­ndice z en 1, lo que lo coloca encima de otros elementos*/
      width: 100%;
      /* establece el ancho del div como el ancho completo de la ventana del navegador*/
      height: 50px;
      /* establece la altura del div en 50 pÃ­xeles*/
      background-color: transparent;
      /* establece el fondo del div como transparente*/
      /* otros estilos para la barra de navegaciÃ³n */
    }

    #interfaz {
      text-align: center;
      font-family: 'Sigmar', cursive;
    }

    #miDiv>span {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .miDivC>span {
      font-family: 'Creepster', cursive;
      font-size: 84px;
      color: brown;
    }
  </style>
</head>

<body>
  <!-- Canvas where the render shows -->
  <canvas id="myCanvas"></canvas>

  <!-- Interfaz -->
  <div id="interfaz">
    <div id="miDiv">Distancia en x: <span id="distanciaX"></span></div>
    <div id="miDiv">Altura: <span id="altura"></span></div>
  </div>

  <!-- AquÃ­ va todo el cÃ³digo de three.js -->
  <script type="module">
    // ğŸ“š  LibrerÃ­as importadas para hacer funcionar three.js y el OrbitControls
    import * as THREE from './js/three.module.js';
    import { OrbitControls } from './js/OrbitControls.js';

    import { TWEEN } from './js/tween.module.min.js'; //ğŸ‘ˆ Importar librerÃ­a de TWEEN.


    // âš™ï¸ Renderer
    var renderer = new THREE.WebGLRenderer({
      canvas: document.getElementById('myCanvas'),
      antialias: true,
    });
    renderer.setPixelRatio(window.decivePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // ğŸ¬ Creando nueva escena
    var scene = new THREE.Scene();

    // â›… Textura del entorno o domo
    var loader = new THREE.TextureLoader();
    loader.load('./img/textura.jpg', function (texture) { // ğŸ‘ˆ Reemplaza la ruta por la ruta y nombre de tu textura
      texture.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = texture;
      scene.background = texture;
      scene.background = texture;
    });

    // ğŸ“· Creando nueva cÃ¡mara de perspectiva
    var camera = new THREE.PerspectiveCamera(
      70,
      window.innerWidth / window.innerHeight,
      0.1,
      500
    );
    scene.add(camera);

    // ğŸ’» Evento para redimensionar el 'canvas'//------------------------------------------
    // ğŸ“ Sizes: Objeto donde se toman los tamaÃ±os interiores 'inner' de la ventana.
    const sizes = {
      width: window.innerWidth,
      height: window.innerHeight,
    };

    // ğŸ–¼ Tomando el 'canvas' mediante el id 'myCanvas' de nuestro HTML para cambiar sus dimensiones
    const canvas = document.getElementById('myCanvas');

    // ğŸ‰ Evento que se ejecutarÃ¡ al redimensionar 'resize' nuestra ventana
    window.addEventListener('resize', () => {
      // Actualizando los valores del objeto 'sizes' con las medidas internas de la ventana
      sizes.width = window.innerWidth;
      sizes.height = window.innerHeight;

      // ActualizaciÃ³n de los valores en la cÃ¡mara como la relaciÃ³n-aspecto y la matriz de proyecciÃ³n.
      camera.aspect = sizes.width / sizes.height;
      camera.updateProjectionMatrix();

      // Aplicando al render el nuevo tamaÃ±o del 'viewport'
      renderer.setSize(sizes.width, sizes.height);
    });

    // // ğŸ® AÃ±adiendo los OrbitControls
    // var controls = new OrbitControls(camera, renderer.domElement);
    // controls.enableDamping = true;
    // controls.dampingFactor = 0.05;

    // AÃ±adiendo GridHelper
    const size = 10000;
    const divisions = 1000;
    const gridHelper = new THREE.GridHelper(size, divisions);
    scene.add(gridHelper); //Si lo quitas explota todo

    // ğŸ›©ï¸ğŸ›©ï¸ğŸ›©ï¸ğŸ›©ï¸ Avioneta ğŸ›©ï¸ğŸ›©ï¸ğŸ›©ï¸ğŸ›©ï¸

    // Elementos
    const geometry = new THREE.SphereGeometry(1, 32, 16);
    const material = new THREE.MeshLambertMaterial({ color: 0x34849E });
    const fuselaje = new THREE.Mesh(geometry, material);
    fuselaje.scale.x = 2;
    scene.add(fuselaje);

    const alas = new THREE.Mesh(geometry, material);
    alas.scale.y = 0.3;
    alas.scale.z = 4;
    alas.position.y = 0.5;
    scene.add(alas);

    const estabilizador_vertical = new THREE.Mesh(geometry, material);
    estabilizador_vertical.scale.x = 0.5;
    estabilizador_vertical.scale.y = 0.8;
    estabilizador_vertical.scale.z = 0.2;
    estabilizador_vertical.position.x = -1.5;
    estabilizador_vertical.position.y = 0.5;
    scene.add(estabilizador_vertical);

    const estabilizador_horizontal = new THREE.Mesh(geometry, material);
    estabilizador_horizontal.scale.x = 0.4;
    estabilizador_horizontal.scale.y = 0.8;
    estabilizador_horizontal.scale.z = 0.1;
    estabilizador_horizontal.rotation.x = Math.PI * 0.5;
    estabilizador_horizontal.rotation.y = Math.PI * 1;
    estabilizador_horizontal.position.y = 1;
    estabilizador_horizontal.position.x = -1.5;
    scene.add(estabilizador_horizontal);

    const helice1 = new THREE.Mesh(geometry, material);
    helice1.position.x = 2;
    helice1.scale.x = 0.1;
    helice1.scale.y = 0.8;
    helice1.scale.z = 0.2;
    scene.add(helice1);

    const helice2 = helice1.clone();
    helice2.position.x = 2;
    helice2.rotation.x = Math.PI * 0.5;
    scene.add(helice2);

    //Grupo de helices 
    var grupo_de_helices = new THREE.Group();

    // AÃ±adiendo cada hÃ©lice al grupo
    grupo_de_helices.add(helice1, helice2);

    //AÃ±adiendo el grupo a la escena
    scene.add(grupo_de_helices);

    var toda_la_avioneta = new THREE.Group();
    toda_la_avioneta.add(
      fuselaje,
      alas,
      estabilizador_horizontal,
      estabilizador_vertical,
      grupo_de_helices,
      Luces
    );
    scene.add(toda_la_avioneta);

    //ğŸ”¦ Luces
    var light01 = new THREE.PointLight(0xffffff, 1);
    light01.position.set(-10, 0, 10);
    scene.add(light01);

    var light02 = new THREE.PointLight(0xffffff, 1);
    light02.position.set(100, -10, 30);
    scene.add(light02);

    var Luces = new THREE.Group();
    Luces.add(
      light01,
      light02
    );
    scene.add(Luces);

    //Settings de la cÃ¡mara
    camera.position.set(0, 0, 10);

    //ğŸ‘‡ CÃ³digo para animar la avioneta arriba abajo

    // âŒš Reloj three.js
    var clock = new THREE.Clock();

    // ğŸ‘Ÿ Movimiento sinusoidal de la avioneta
    var velocidad = 4, amplitud = 0.5;

    // CÃ³digo de la funciÃ³n


    // DeclaraciÃ³n de la funciÃ³n
    function avioneta_movimiento_sin() {
      toda_la_avioneta.position.y = toda_la_avioneta.position.y + Math.sin(clock.getElapsedTime() * velocidad) * amplitud;
    }

    // ğŸ”® - - - - - - Magia del tweening - - - - - -
    // Objeto de posiciones 
    var posiciones_originales = {
      posicion_en_x: 0,
      posicion_en_y: 0,
      posicion_en_z: 0,
      rotacion_en_x: 0, // ğŸ‘ˆ Nuevas propiedades para rotar el objeto.
      rotacion_en_z: 0, // ğŸ‘ˆ 
    };

    var nuevas_posiciones = {
      posicion_en_x: 20,
      posicion_en_y: 4,
      posicion_en_z: 0,
    };

    //Objeto tween
    var tween = new TWEEN.Tween(posiciones_originales);
    // tween.repeat(Infinity)
    var tween_rotation = new TWEEN.Tween(posiciones_originales); //ğŸ‘ˆ Nuevo objeto 'tween'


    //FunciÃ³n magia_tweening() para inicializar el interpolado
    function magia_tweening() {
      tween.to(nuevas_posiciones, 2000);
      tween.start();
    }

    magia_tweening();

    // PosiciÃ³n de cÃ¡mara
    camera.position.set(-10, 4, 0);

    // ğŸ®ğŸ®ğŸ® InteracciÃ³n  ğŸ®ğŸ®ğŸ®
    document.addEventListener('keydown', function (event) {
      if (event.key === 'ArrowUp') {
        tween.to({ posicion_en_y: toda_la_avioneta.position.y + 1 }, 400);
        tween.start();

        tween_rotation.to({ rotacion_en_z: Math.PI * (1 / 8) }, 200); // ğŸ‘ˆ Personaliza el giro
        tween_rotation.repeat(1);
        tween_rotation.easing(TWEEN.Easing.Quadratic.InOut); // ğŸ‘ˆ Personaliza el estilo del 'tweening'
        tween_rotation.yoyo(true);
        tween_rotation.start();

        console.log('Altura de la avioneta: ' + toda_la_avioneta.position.y); //ğŸ‘ˆğŸ‘ˆ Muestra la altura por consola

      }
    });

    document.addEventListener('keydown', function (event) {
      if (event.key === 'ArrowDown') {
        tween.to({ posicion_en_y: toda_la_avioneta.position.y - 1 }, 400);
        tween.start();

        tween_rotation.to({ rotacion_en_z: Math.PI * -(1 / 8) }, 200); // ğŸ‘ˆ Personaliza el giro
        tween_rotation.repeat(1);
        tween_rotation.easing(TWEEN.Easing.Quadratic.InOut); // ğŸ‘ˆ Personaliza el estilo del 'tweening'
        tween_rotation.yoyo(true);
        tween_rotation.start();

        console.log('Altura de la avioneta: ' + toda_la_avioneta.position.y); //ğŸ‘ˆğŸ‘ˆ Muestra la altura por consola

      }

      if (event.key === 'ArrowLeft') {
        tween.to({ posicion_en_z: toda_la_avioneta.position.z - 1 }, 400);
        tween.start();

        tween_rotation.to({ rotacion_en_x: Math.PI * -(1 / 8) }, 200); // ğŸ‘ˆ Personaliza el giro
        tween_rotation.repeat(1);
        tween_rotation.easing(TWEEN.Easing.Quadratic.InOut); // ğŸ‘ˆ Personaliza el estilo del 'tweening'
        tween_rotation.yoyo(true);
        tween_rotation.start();


      }

      if (event.key === 'ArrowRight') {
        tween.to({ posicion_en_z: toda_la_avioneta.position.z + 1 }, 400);
        tween.start();

        tween_rotation.to({ rotacion_en_x: Math.PI * (1 / 8) }, 200); // ğŸ‘ˆ Personaliza el giro
        tween_rotation.repeat(1);
        tween_rotation.easing(TWEEN.Easing.Quadratic.InOut); // ğŸ‘ˆ Personaliza el estilo del 'tweening'
        tween_rotation.yoyo(true);
        tween_rotation.start();
      }

      if (event.key === 'Backspace') {
        tween.to(
          {
            posicion_en_x: 0,
            posicion_en_y: 0,
            posicion_en_z: 0,
          }
          , 400);
        tween.start();

        tween_rotation.easing(TWEEN.Easing.Quadratic.InOut); // ğŸ‘ˆ Personaliza el estilo del 'tweening'

      }

      if (event.key === 'Enter') {
        magia_tweening();
      }

      if (event.key === ' ') {
        tween.to({ posicion_en_y: toda_la_avioneta.position.y - 2 }, 400);
        tween.start();

        tween_rotation.to({ rotacion_en_x: Math.PI * 2 }, 500); // ğŸ‘ˆ Personaliza el giro
        tween_rotation.repeat(1);
        tween_rotation.easing(TWEEN.Easing.Quadratic.InOut); // ğŸ‘ˆ Personaliza el estilo del 'tweening'
        tween_rotation.yoyo(true);
        tween_rotation.start();

      }

    });


    // â˜â˜â˜â˜ NUBES â˜â˜â˜â˜
    //Creando un nube
    let geometry_nube = new THREE.SphereGeometry(1, 13, 8);
    let material_nube = new THREE.MeshBasicMaterial({
      color: 0xf1f1f1,
      transparent: true,
      opacity: 0.5,
      wireframe: false,
    });
    let mesh1_nube = new THREE.Mesh(geometry_nube, material_nube);
    let mesh2_nube = new THREE.Mesh(geometry_nube, material_nube);
    let mesh3_nube = new THREE.Mesh(geometry_nube, material_nube);

    mesh1_nube.position.set(0, 0, -1);
    mesh2_nube.position.set(0, 0.2, -0);
    mesh3_nube.position.set(0, 0, 1);

    //Creando el grupo que conforma 1 nube
    let grupo_nube = new THREE.Group();

    //AÃ±adiendo al grupo de 1 nube
    grupo_nube.add(mesh1_nube);
    grupo_nube.add(mesh2_nube);
    grupo_nube.add(mesh3_nube);

    //Escalando el grupo de 1 nube
    grupo_nube.scale.set(10, 10, 10);

    //Grupo de muchas nubes
    let grupo_de_nubes = new THREE.Group();

    //Variables del random
    const random_min = -8;
    const random_max = 8;

    //Bucle que genera el conjunto de 10 nubes
    for (let iteracion = 0; iteracion < 80; iteracion++) { //ğŸ‘ˆ Ciclo for, que generarÃ¡ 10 nubes

      let nube = grupo_nube.clone(); //clonando el grupo, aÃ±adiendo a la variable nube
      let nube_2 = grupo_nube.clone();

      //Cambiando la posiciÃ³n de la nube generada
      nube.position.x = iteracion * 20; // Esta es la separaciÃ³n entre cada nube: la iteraciÃ³n
      nube.position.y = Math.floor(Math.random() * (random_max - random_min + 1)) + random_min;
      nube.position.z = Math.floor(Math.random() * (random_max - random_min + 1)) + 55;

      nube_2.position.x = iteracion * 20 + 10;
      nube_2.position.y = Math.floor(Math.random() * (random_max - random_min + 1)) + random_min;
      nube_2.position.z = Math.floor(Math.random() * (random_max - random_min + 1)) - 55;


      //AÃ±adiendo nueva nube al grupo de nubes
      grupo_de_nubes.add(nube, nube_2);

    }

    grupo_de_nubes.position.y = -15; //Colocando el grupo de nubes debajo del nivel de suelo.

    scene.add(grupo_de_nubes);

    /*================================ Movimiento de la cÃ¡mara ==============================*/
    var aceleracion = 0;
    var factor_velocidad_hacia_adelante = 0.1;

    function seguir_avioneta_camara() {
      camera.position.x = toda_la_avioneta.position.x - 20;
      camera.position.y = toda_la_avioneta.position.y + 3;
      camera.position.z = toda_la_avioneta.position.z;
    }

    function desplazamiento_avioneta() {
      toda_la_avioneta.position.x += factor_velocidad_hacia_adelante;
    }

    camera.lookAt(1, 0, 0)


    //ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥Rendering y animaciÃ³nğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
    requestAnimationFrame(render);
    function render() {
      //ğŸ’ƒ AnimaciÃ³n
      toda_la_avioneta.position.y = posiciones_originales.posicion_en_y;
      toda_la_avioneta.position.x = posiciones_originales.posicion_en_x;
      toda_la_avioneta.position.z = posiciones_originales.posicion_en_z;

      toda_la_avioneta.rotation.z = posiciones_originales.rotacion_en_z;
      toda_la_avioneta.rotation.x = posiciones_originales.rotacion_en_x;
      TWEEN.update();
      grupo_de_helices.rotation.x += 0.2;
      avioneta_movimiento_sin();
      //ğŸ’ƒ AnimaciÃ³n

      //ActualizaciÃ³n del OrbitControls para generar la suavidad de movimiento
      // controls.update();

      const elemento_distanciaX = document.getElementById('distanciaX'); // busca el elemento con id 'distanciaX' y lo asigna a la variable 'span
      const elemento_altura = document.getElementById('altura');

      elemento_distanciaX.textContent = toda_la_avioneta.position.x; // establece el contenido del elemento 'span' como el valor de la posiciÃ³n X de un objeto llamado 'toda_la_avioneta'
      elemento_altura.textContent = toda_la_avioneta.position.y;



      //Llamado para renderizar y volver a llamar a la misma funciÃ³n (render)
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
  </script>
</body>

</html>